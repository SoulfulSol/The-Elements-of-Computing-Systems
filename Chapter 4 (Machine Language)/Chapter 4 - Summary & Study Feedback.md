## Chapter 4 - Contents Summary & Study Feedback  (20.02.20)



<Contents Summary>

```
본 챕터부터는 Chapter 1,2,3에서 다루었던 Chip들의 구현에서 나아가, 본격적인 컴퓨터 전체 구조에 대해 다루기 시작한다. 기계어, 어셈블리, 메모리, CPU, 레지스터 등 운영체제 혹은 컴퓨터 구조 수업에서 다루는 개념들이 등장하고 각 구성요소들이 어떻게 작동하고 상호작용하는지를 설명한다.
```

---



##### 1. 기계어 & 어셈블리어

- 말 그대로 기계가 이해하는 언어. 기계는 0과 1의 2진수만 이해하는 기계이기 때문에, 기계어는 010101...과 같은 형식으로 되어있다.

- 흔히 생각하는 '코딩'의 언어는, 어떠어떠한 과정을 통해 결국 이러한 2진수로 바뀌게 된다.

  ```
  고수준 언어(Java, C, 파이썬 등) -> 컴파일러로 변환 -> 어셈블리어로 변환(할 수도 있고 안 할 수도 있음) -> 2진 기계어로 변환
  ```

- 고수준 언어는 프로그래머의 **머릿속의 추상적 개념을 논리적으로 구현하는 것**이 목표라면, 기계어는 결국 그 개념을 **하드웨어상에서 실행하고 제어하는 것이 목표**다.

- 다시말해 기계어란, **'Processor 와 Register들을 이용해서 Memory를 조작할 수 있도록 미리 정의된  코드화된 규칙'**이라 볼 수 있다.

- **1010001100011001** 과 같은 코드는 16개의 2진수로서, 16비트 2진코드라 할 수 있다. 이러한 기계어는 그 종류와 설계 방법에 따라 '**해독방법'**이 다르다. 

- 해독방법이 어느정도 정해져 있다면, 굳이 0과 1을 이용해서 다 표기하지 않고 어떤 특정 기호를 이용해서 표시할 수도 있을 것이다. 

- 예를들어 16비트 2진수에서 앞 4자리 1010을 'ADD', 다음 각 4자리를 3가지 레지스터의 종류 라고 정의한다면  '1010 0001 0010 0011' 은 'R1 = R2 ADD R3' 와 같은 기호로 대체될 수 있을 것이다. 

- 이처럼 복잡한 2진 기계어를 알아보기 쉽게 표현한 언어를 **'어셈블리어'**라고 한다. 어셈블리 문법은 CPU의 종류에 따라 다를 수 있다.

- 그 중 우리 교재에서 다룰 기계어는 **'Hack Language(Assembly & Machine language)'**이다.

  

##### 2. Hack Language Specification

- 그렇다면 교재에서 다루는 핵 기계어는 어떤 규칙들로 이루어져있나? 그걸 알기 위해서는, 우선 이 'Hack Computer'가 어떤 모듈들로 이루어져있는지 봐야 한다.

- 핵 컴퓨터는 'Von Neumann(폰 노이만)' 플랫폼으로서, **CPU(2개의 레지스터 존재), 명령어 메모리, 데이터 메모리, 스크린 및 키보드**로 구성되어 있는 **16비트** 장치다.

  - 명령어 메모리 : 명령어들만 잔뜩 들어있는 Read Only Memory (ROM)

  - 데이터 메모리 : 명령어를 실행 후 데이터를 저장하는 Memory

  - 16비트 레지스터 A : Address. 주소값을 저장할 수 있고, 데이터를 저장할 수도 있다(두 가지 역할을 다 한다).

  - 16비트 레지스터 D : Data. 데이터 값을 저장한다.

  - 레지스터의 작동방식 : **M**기호는 현재 A레지스터가 가리키고 있는 주소의 Value를 의미한다.  **D**기호는 D레지스터에 데이터를 저장하라는 의미다. 

  - 16비트의 핵 문법은 명령어(16비트)와 주소(16비트)를 한꺼번에 담기에는 16비트가 모자라므로, 두 번의 절차를 거쳐야 한다 : 1) A레지스터에 특정 주소의 value를 담아라(**M**) 2) 그 다음 D레지스터에 A레지스터의 Value에 1을 더한 값을 저장하라. \

  - 즉 D = M + 1은 'D레지스터에 현재 A레지스터가 가리키고 있는 주소의 Value에 1을 더한 값을 저장하라'는 의미다. 

  - 명령어 : **A-명령어(Address**) 와 **C-명령어(Calculation)**가 있다.

    - A-명령어 : 핵 어셈블리에서는 @Value 로 표현되며, A레지스터에 특정 값을 저장하라는 의미이다. 이것은 상수일수도, 특정 데이터의 주소값일수도, 다음 프로그램카운터가 가리킬 점프 주소값일수도 있다.

    - C-명령어 : D, A, M 의 값을 계산하고,  1을 더하거나 빼거나 하는 명령어다.  핵 어셈블리에서는 D = M + 1 과 같이 나타나고, 핵 기계어에서는 특정 규칙을 따른다.

      --> Ex) 1111 1111 1111 1111 이라는 16비트 기계어는 comp(미리 정해진 함수 계산), dest(destination, 계산 결과 저장 공간 - M, D, A중 어디 저장할지), jump(점프할 조건) 으로 분리되어 해독된다.

  - 스크린과 키보드 : 핵 플랫폼에서 I/O장치인 키보드와 스크린은, 각각 Mapping된 메모리 RAM 주소에 대응한다.

    - 스크린 : 핵 플랫폼의 스크린은 512 x 256 의 흑백픽셀로 구성되어 있고, RAM의 한 비트에 대응되므로, 스크린의 특정 픽셀을 검게 만들고 싶으면(1) 해당 비트를 1로 만들면 된다.
    - 키보드 : 스크린과 비슷하게, 키보드의 특정 키가 눌릴 때 마다 눌린 키의 16비트 ASC2 코드가 RAM에  기록된다. 눌리지 않으면 0이 기록된다.



**2. Project 스터디 피드백**

- 단순히 칩만 만들다가 갑자기 어셈블리, 기계어로 내용이 Jump해서 너무 어려웠다. 챕터 4 자체를 10번은 넘게 읽은 듯 하다. 
- 내가 어셈블리, 기계어, 메모리, 레지스터 등에 대한 개념이 잡혀있지 않아서 처음에 책을 읽고 소화하기 힘들었다. 인터넷으로 관련 내용을 찾아가며 개념을 익히고 책을 다시 읽으니 훨씬 그림이 잘 그려졌다.
- 또한 책에 실린 프로젝트를 한번 하고 나니, '아, 이게 어셈블리의 역할이구나', '아, 이게 어셈블리가 변환한 2진 코드 결과물이구나', '아, I/O장치가 이렇게 작동하는구나' 등을 직접 체감할 수 있었다.
- 한 챕터 한 챕터가 솔직히 버겁지만, 점점 컴퓨터 구조에 대한 그림이 조각조각 그려져가는 느낌이 꽤나 즐겁다. 
- 컴퓨터 공부를 하면서 느끼는건데, 이 책도 그렇고 인강도 그렇고 내가 해왔던 프로젝트도 그렇고 하나같이 전부다 '불친절'하다. 하나하나 절대 구체적으로 가르쳐주지 않는다. 그런데 신기하게도, 중간에 포기하지 않고 알아내려 애를 쓰고 삽질을 반복하다보면 어느새 갑자기 **'체득'**된다. 마치 영어 단어를 무작정 외워놓았는데, 미드를 보다가 어느순간 그 단어가 쓰이는 Context를 느끼고 그 단어의 쓰임을 체득하는 것 처럼.
- 어쩌면 이 방법이 가장 효과적인 방법이니까 전부 불친절한 것 아닐까? 알고리즘 스터디에서도, 처음엔 내 수준에 맞지 않는 문제를 풀고있는게 아닐까 괜시리 걱정이 되었는데, 하나씩 풀다보니 어느새 자료구조와 알고리즘의 개념을 저절로 체득하고 있는 나 자신을 발견해간다. 
- 따라서, '삽질'에 너무 스트레스 받지 말고, '배움의 과정'이라 생각하고 즐기는 마음가짐으로 접근하자. 결국 이렇게 반복되는 Challenge는 나를 성장시키고, 그것을 나는 매 순간 느끼고 있기 때문이다. 
