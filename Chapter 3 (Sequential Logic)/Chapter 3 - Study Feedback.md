## Chapter 3 - Contents Summary & Study Feedback  (20.01.28)



<Contents Summary>

##### 1.순차 칩

- Chapter 1, 2 에서 다룬 내용은 모두 '조합 칩(Combination Chip)'이었는데, 이 칩들은 입력값의 조합에만 의존하는 함수를 계산한다. 다시 말해 input값들을 계산해주기는 하나, 그 값을 유지해주지는 않는다.
- 컴퓨터는 값을 저장하고 다시 불러올 수 있어야 하기 때문에, '메모리 소자'가 필요하며, 메모리 소자는 조합 칩이 아닌 **'순차 칩'**으로 만든다.
- **'메모리'**란 **'과거의 시간을 기억'** 하는 것이다. 즉, t라는 시점에 t-1시점의 기억을 가져올 수 있다면, 혹은 t-100시점의 기억을 계속 유지하고 있다가 t시점에 그 기억을 꺼낼 수 있다면, 그것은 가히 메모리의 기능을 한다고 이야기 할 수 있을 것이다.
- 이러한 한 시점을 '클록'이라 하며, 클록 신호는 컴퓨터 하드웨어에 동시에 전달된다.
- out(t) = in(t-1) 이라는 가장 기본적인 역할을 하는 칩이 **DFF(Data Flip Flop)**다. DFF는 컴퓨터의 상태를 유지하는 모든 하드웨어의 기초다.
- **Register**는 값을 '저장'할 뿐만 아니라 새로 '로드'할 수 있는 장치다. Load 신호에 따라 지난 시점의 값을 계속 불러오기도, 현재 시점의 값을 저장하기도 한다.
- 레지스터 하나에 하나의 비트가 기억된다면, 레지스터를 16,32,64 등으로 배열하면 각각 16비트, 32비트, 64비트를 기억할 수 있을 것이다. 이처럼 레지스터에 저장되는 멀티비트 값을 '단어(Word)'라 한다.
- **RAM**은 Register가 여러 개 모여서 만들어 진 칩이다. 각각의 Register는 주소값을 지니고 있으며, RAM은 직접 접근 논리(교재에서는 다루지 않음)를 통해 각 레지스터의 단어에 접근한다. 
- RAM으로 Address가 입력되면 Address에 따라 Register를 찾는데, 가령 Register가 8개 들어있는 RAM8에 Address가 [3] (3비트)로 주어진다면, 0~7까지 각각의 레지스터를 가리킨다고 해석할 수 있을것이다.
- 마찬가지로, 만약 RAM8이 8개 들어있는 RAM64와 같은 경우에는, RAM을 가리키는 address가 6비트, 그 속의 8개 Register를 가리키는 Address가 3비트, 총 '9비트'의 주소가 Address[9] 와 같은 형태로 주어질 수 있다.
- 주소대로 Address를 찾아가는 것을 어떻게 구현할까? 앞에서 DMUX와 MUX를 괜히 배운것이 아니었다.
- **Program Counter** 는  운영체제 강의에서만 흘려듣고 지나간 칩인데, 여기서 이렇게 등장해서 내게 충격을 선사할 줄 꿈에도 몰랐다. 
- 프로그램 카운터, 즉 계수기는 컴퓨터가 다음에 수행할 명령어(Word)가 있는 주소를 가리키는 놈이다.  어떤 프로그램이 실행되면, 대부분의 프로세서는 어떤 명령어를 실행함과 동시에 계수기를 증가시켜 다음에 실행할 명령을 가리켜 놓는다. 이렇게 연속적인 프로그램 실행이 가능해지는 것이다. 
- 순차 칩이 들어간 조합 칩의 강력함은 다음과 같다. 조합 칩은 시간과 무관하게 입력값이 들어오면 출력을 실시한다. 그런데 순차칩이 들어가는 순간, 조합칩의 output은 '**한 클록 사이클이 넘어갈 때**' 비로소 바뀌게 된다. 이 특성을 이용하면 전체 컴퓨터 아키텍쳐의 '**Synchronization**'이 가능해진다! 즉, 컴퓨터 아키텍쳐 내부 모든 조합 칩의 output들이 다음 클록 사이클까지 유효성이 보장되는 것이다. --> 매우 중요한 포인트다.



**2. Project 스터디 피드백**

- PC의 구현이 매우 어려웠다. 내일 스터디 시간에 Mong과 함께 풀어보고 이 챕터를 정리하는 걸로..